<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020" />
  <!-- iOS PWA tags -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Rad Angle" />
  <!-- Apple touch icon (embedded 256px data URL) -->
  <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABxJJREFUeNrs3UGS2zgQBVBL//9k5kq1r5b0T+eVqUQk1fW8mJ1kqk2YtH4b4C6Dk2nZ3wqgBv0H1v0w6u6g2JpP3wVg0RkAAIhF8r1c2dVSkj2d3zv1cQ3cfn8vQCAAAAgC8n4YwZGRkZGRkZGaZbSa7d8x7m9bZlq/8v3i8Xn8bq9a2z8WJYp7g9wqCqVb7/1k9P6b7w5kqg8wqEo4Q4g8xwqkqg9wqEo4Q4g8xwqkqg9wqEo4Q4g8xwqkqg9wqEo4Q4g8xwqkqg9+u2b9j3bVt2bftJwK8fP34n2Lt+vWuz7f1a7p8v7w8F4bGxs/P7+vqo7P5+fmnw8PDQ0NDQ8M2WZbvtc9m2X3l2u3s8y1b9v9j0bYv7e7aZb1f1/0Ff8kHhM3gkQAAACg8X8pXc9g9l8x9cqlEolq9Xq9Wq1+vx+Pz6fP7bZbPp+PB4PBoPB7/f4bIsy8rKynJzc3Nra+vUarVa/X4/H4fHx8cHBwbIsCxsbG1tbW2tra+np6fH19bIsC4rFYrFYrPT09dXV1+v3+5eVlq9Xq6+sr7Xb7fT4fGxub7Xa7m83mJEmS+Xy+np6cSAAAgP8m7xgAAABg6C5nAgAAAGDoLmcCAAAAYOguzf4Jw6bJw4M3gF6Gf3c4vUwp2u8g0Hq+0K1A6m+qgWk1H4J1wH1m6g8YF8Jr1v4Xgqj2o0Gxk2t7Q7lN9j9D7lN9j9Dx1v8mWZZlWq1Wv1+Px+Hx8fHBwcGxsbG1tbW2tra2ZmZkymQwAAAAAAMJH+QYAAABg6C5nAgAAAGDoLmcCAAAAYOgudwIAD1wz7QmG3zv8v98zJf1o9g0AAAAASUVORK5CYII=" />
  <!-- Web App Manifest: injected at runtime so this remains single-file -->
  <link id="pwa-manifest" rel="manifest" />
  <title>Radiograph Angle Tool — Mobile + Camera</title>
  <style>
    :root { --bg:#0b1020; --panel:#121a33; --ink:#e9eefb; --muted:#9fb3ff; --accent:#6aa7ff; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: var(--ink); background: linear-gradient(180deg,#0a0f1e,#0e1530); }
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; gap: 8px; }
    header { padding: 10px 12px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.06); display: grid; gap: 8px; }
    .brand { font-weight: 700; letter-spacing: .25px; }
    .toolbar { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
    .toolbar > * { background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; color: var(--ink); font-size: 14px; min-height: 42px; }
    select, button, input[type="file"] { width: 100%; }
    button { background: #1b2550; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 2px 10px rgba(0,0,0,0.25) inset; }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: .5; }
    #canvasWrap { position: relative; height: 100%; background: #060914; border-top: 1px solid rgba(255,255,255,0.05); border-bottom: 1px solid rgba(255,255,255,0.05); touch-action: none; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; outline: none; }
    video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: #000; display:none; }
    .side { display: grid; grid-template-columns: 1fr; height: 100%; }
    .panel { background: var(--panel); border-top: 1px solid rgba(255,255,255,0.08); padding: 10px; overflow: auto; max-height: 32vh; }
    .panel h3 { margin: 6px 0 6px; font-size: 13px; color: var(--muted); }
    .panel .list { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.35; }
    .pill { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); font-size: 12px; color: #c9d6ff; }
    footer { padding: 8px 12px; font-size: 12px; color: var(--muted); display: flex; justify-content: space-between; align-items: center; gap: 6px; flex-wrap: wrap; }
    .kbd { font-family: ui-monospace, Menlo, monospace; background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.12); }
    .row { display:flex; gap:8px; align-items:center; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">Radiograph Angle Tool <span class="pill">Mobile + Camera</span></div>
      <div class="toolbar">
        <button id="startCam">Start Camera</button>
        <button id="switchCam" disabled>Switch Cam</button>
        <button id="snap" disabled>Capture</button>
        <input id="fileInput" type="file" accept="image/*" />
        <select id="mode">
          <option value="HVA">HVA — Hallux Valgus Angle</option>
          <option value="IMA">IMA — 1st–2nd Intermetatarsal</option>
          <option value="CALC_INC">Calcaneal Inclination</option>
          <option value="LINE_LINE">Line–Line Angle (generic)</option>
        </select>
        <select id="baseline">
          <option value="HORIZ">Baseline: Image Horizontal</option>
          <option value="CUSTOM">Baseline: Custom (place 2 pts)</option>
        </select>
        <button id="undo">Undo</button>
        <button id="clearAll">Clear All</button>
        <button id="resetView">Reset View</button>
        <button id="exportPNG">Export PNG</button>
      </div>
      <div id="hint" style="color:var(--muted);font-size:12px">Load an image or use the camera. Tap to add points; pinch to zoom; drag to pan; double‑tap to reset.</div>
    </header>

    <div class="side">
      <div id="canvasWrap">
        <video id="video" playsinline></video>
        <canvas id="canvas" tabindex="0" aria-label="radiograph canvas"></canvas>
      </div>
      <aside class="panel">
        <h3>Current Mode <span id="modeBadge" class="pill">HVA</span></h3>
        <div id="instructions" class="list"></div>
        <h3>Measurements</h3>
        <div id="measurements" class="list">None yet.</div>
      </aside>
    </div>

    <footer>
      <div>
        <span class="kbd">Pinch</span> zoom · <span class="kbd">Drag</span> pan · <span class="kbd">Double‑tap</span> reset
      </div>
      <div>Works offline if added to Home Screen (PWA-ready).</div>
    </footer>

    <!-- Lightweight install hint (Android/desktop). iOS uses Share → Add to Home Screen. -->
    <div id="installBanner" style="display:none;position:fixed;bottom:12px;left:12px;right:12px;background:#1b2550;border:1px solid rgba(255,255,255,.15);padding:10px 12px;border-radius:12px;z-index:50">
      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap">
        <div style="font-size:14px">Install this as an app for offline, full‑screen use.</div>
        <div style="display:flex;gap:8px">
          <button id="installBtn">Install</button>
          <button id="dismissInstall">Dismiss</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const $ = (id) => document.getElementById(id);
    const canvas = $("canvas");
    const ctx = canvas.getContext("2d");
    const video = $("video");
    const dpr = window.devicePixelRatio || 1;

    const state = {
      img: null,
      imgNaturalW: 0, imgNaturalH: 0,
      scale: 1, minScale: 0.1, maxScale: 8,
      offsetX: 0, offsetY: 0,
      isPanning: false,
      startPan: {x:0,y:0},
      currentMode: 'HVA',
      baselineMode: 'HORIZ',
      currentPts: [],
      baselinePts: [],
      measurements: [],
      colorIdx: 0,
      // camera
      stream: null,
      usingCamera: false,
      currentFacing: 'environment',
      // touch
      pointers: new Map(),
      lastPinchDist: null,
    };

    const COLORS = [ '#6aa7ff','#80ffd3','#ffd868','#ff8db3','#a18bff','#8ef0ff','#ffad74' ];
    function nextColor(){ const c = COLORS[state.colorIdx % COLORS.length]; state.colorIdx++; return c; }

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      draw();
    }
    new ResizeObserver(resizeCanvas).observe($("canvasWrap"));

    // Coordinate transforms between screen and image space
    function screenToImage(x,y){
      const cx = (x * dpr - state.offsetX) / state.scale;
      const cy = (y * dpr - state.offsetY) / state.scale;
      return {x: cx, y: cy};
    }
    function imageToScreen(x,y){
      const sx = (x * state.scale + state.offsetX) / dpr;
      const sy = (y * state.scale + state.offsetY) / dpr;
      return {x: sx, y: sy};
    }

    // ---------- Image loading ----------
    function loadImageFromBlob(blob){
      const img = new Image();
      img.onload = ()=>{
        stopCamera();
        state.img = img; state.imgNaturalW = img.naturalWidth; state.imgNaturalH = img.naturalHeight;
        fitImage();
        state.measurements = []; state.currentPts = []; state.baselinePts = []; state.colorIdx = 0;
        renderMeasurementsList();
        draw();
      };
      img.src = URL.createObjectURL(blob);
    }

    $("fileInput").addEventListener('change', (e)=>{
      const file = e.target.files[0]; if(!file) return;
      loadImageFromBlob(file);
    });

    // ---------- Camera ----------
    async function startCamera(){
      try{
        const constraints = { video: { facingMode: state.currentFacing, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        state.stream = stream; state.usingCamera = true;
        video.srcObject = stream; await video.play();
        video.style.display = 'block';
        $("snap").disabled = false; $("switchCam").disabled = false;
        $("startCam").disabled = true;
        $("hint").textContent = 'Aim camera at the film/monitor. Tap Capture.';
      } catch(err){
        alert('Camera access failed: ' + err.message);
      }
    }

    function stopCamera(){
      if(state.stream){
        state.stream.getTracks().forEach(t=>t.stop());
        state.stream = null;
      }
      state.usingCamera = false;
      video.srcObject = null;
      video.style.display = 'none';
      $("snap").disabled = true; $("switchCam").disabled = true; $("startCam").disabled = false;
    }

    async function switchCamera(){
      state.currentFacing = state.currentFacing === 'environment' ? 'user' : 'environment';
      if(state.usingCamera){ stopCamera(); await startCamera(); }
    }

    async function captureFrame(){
      if(!state.usingCamera){ return; }
      // Draw current video frame to an offscreen canvas, then turn into blob
      const off = document.createElement('canvas');
      const vw = video.videoWidth || 1280; const vh = video.videoHeight || 720;
      off.width = vw; off.height = vh; const c2 = off.getContext('2d');
      c2.drawImage(video, 0, 0, vw, vh);
      off.toBlob((blob)=>{ if(blob) loadImageFromBlob(blob); }, 'image/jpeg', 0.95);
    }

    $("startCam").onclick = startCamera;
    $("switchCam").onclick = switchCamera;
    $("snap").onclick = captureFrame;

    // ---------- Fit & View ----------
    function fitImage(){
      const cw = canvas.width, ch = canvas.height;
      const sx = cw / state.imgNaturalW, sy = ch / state.imgNaturalH;
      state.scale = Math.min(sx, sy) * 0.95;
      state.offsetX = (cw - state.imgNaturalW * state.scale) / 2;
      state.offsetY = (ch - state.imgNaturalH * state.scale) / 2;
      state.minScale = Math.min(0.05, state.scale * 0.25);
      state.maxScale = Math.max(8, state.scale * 4);
    }

    // ---------- Modes & Instructions ----------
    const MODE_STEPS = {
      HVA: { steps: [
        'Place 2 pts along FIRST met shaft (prox → dist).',
        'Place 2 pts along PROXIMAL PHALANX (prox → dist).'
      ], needs: 4, build: (pts, color)=>({ type:'HVA', color, lines:[ [pts[0],pts[1]], [pts[2],pts[3]] ] }) },
      IMA: { steps: [
        'Place 2 pts along FIRST met shaft (prox → dist).',
        'Place 2 pts along SECOND met shaft (prox → dist).'
      ], needs: 4, build: (pts, color)=>({ type:'IMA', color, lines:[[pts[0],pts[1]],[pts[2],pts[3]]] }) },
      CALC_INC: { steps: [
        'Place 2 pts along calcaneal inferior border (post → ant).',
        'If Custom Baseline, place 2 baseline pts (hold ⌥ long‑press).'
      ], needs: 2, build: (pts, color)=>({ type:'CALC_INC', color, lines: [[pts[0],pts[1]]] }) },
      LINE_LINE: { steps: [ 'Place 2 pts for Line A.', 'Place 2 pts for Line B.' ], needs: 4, build: (pts, color)=>({ type:'LINE_LINE', color, lines:[[pts[0],pts[1]],[pts[2],pts[3]]] }) }
    };

    function setMode(m){ state.currentMode = m; state.currentPts = []; $("modeBadge").textContent = m; renderInstructions(); draw(); }
    function setBaselineMode(m){ state.baselineMode = m; if(m==='HORIZ') state.baselinePts=[]; renderInstructions(); draw(); }
    $("mode").addEventListener('change', (e)=> setMode(e.target.value));
    $("baseline").addEventListener('change', (e)=> setBaselineMode(e.target.value));

    function renderInstructions(){
      const ms = MODE_STEPS[state.currentMode];
      const lines = [];
      lines.push(`<div>Steps:</div>`);
      ms.steps.forEach((s,i)=> lines.push(`${i+1}. ${s}`));
      if(state.currentMode==='CALC_INC'){
        if(state.baselineMode==='HORIZ'){
          lines.push('<em>Baseline:</em> image horizontal assumed.');
        } else {
          lines.push('<em>Baseline:</em> place 2 custom baseline pts (e.g., floor). On mobile: tap the ⓑ button to toggle baseline placement.');
        }
      }
      $("instructions").innerHTML = lines.map(l=>`<div>• ${l}</div>`).join('');
    }
    renderInstructions();

    // ---------- Interaction (Pointer/Touch) ----------
    // Support: tap to add points, drag to pan, pinch to zoom, double-tap to reset.
    let lastTap = 0;

    function onPointerDown(e){
      canvas.setPointerCapture(e.pointerId);
      state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if(state.pointers.size === 2){
        const [a,b] = Array.from(state.pointers.values());
        state.lastPinchDist = Math.hypot(a.x-b.x, a.y-b.y);
        return;
      }
      if(!state.img){ state.isPanning = true; state.startPan={x:e.clientX,y:e.clientY}; return; }
      // Single-finger: place point
      const now = Date.now();
      if(now - lastTap < 300){ // double tap
        resetView();
        lastTap = 0; return;
      }
      lastTap = now;
      const rect = canvas.getBoundingClientRect();
      const pt = screenToImage(e.clientX - rect.left, e.clientY - rect.top);

      if(state.currentMode==='CALC_INC' && state.baselineMode==='CUSTOM' && state.baselinePts.length < 2 && e.altKey){
        state.baselinePts.push(pt); draw(); return;
      }

      state.currentPts.push(pt);
      const needs = MODE_STEPS[state.currentMode].needs;
      if(state.currentPts.length === needs){
        const color = nextColor();
        const measurement = MODE_STEPS[state.currentMode].build(state.currentPts.slice(), color);
        if(state.currentMode==='CALC_INC' && state.baselineMode==='CUSTOM' && state.baselinePts.length===2){
          measurement.baseline = [ state.baselinePts[0], state.baselinePts[1] ];
        }
        computeMeasurement(measurement);
        state.measurements.push(measurement);
        state.currentPts = [];
        renderMeasurementsList();
      }
      draw();
    }

    function onPointerMove(e){
      if(state.pointers.has(e.pointerId)){
        state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      }
      if(state.pointers.size === 2){
        const [a,b] = Array.from(state.pointers.values());
        const dist = Math.hypot(a.x-b.x, a.y-b.y);
        if(state.lastPinchDist){
          const zoom = dist / state.lastPinchDist;
          const rect = canvas.getBoundingClientRect();
          const mx = ((a.x+b.x)/2 - rect.left) * dpr; const my = ((a.y+b.y)/2 - rect.top) * dpr;
          const newScale = Math.min(state.maxScale, Math.max(state.minScale, state.scale * zoom));
          const k = newScale / state.scale;
          state.offsetX = mx - (mx - state.offsetX) * k;
          state.offsetY = my - (my - state.offsetY) * k;
          state.scale = newScale;
          draw();
        }
        state.lastPinchDist = dist;
        return;
      }
      if(state.isPanning){
        const dx = (e.clientX - state.startPan.x) * dpr;
        const dy = (e.clientY - state.startPan.y) * dpr;
        state.offsetX += dx; state.offsetY += dy; state.startPan = {x:e.clientX, y:e.clientY};
        draw();
      }
    }

    function onPointerUp(e){
      canvas.releasePointerCapture(e.pointerId);
      state.pointers.delete(e.pointerId);
      if(state.pointers.size < 2){ state.lastPinchDist = null; }
      state.isPanning = false;
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // Keyboard shortcuts (desktop fallback)
    window.addEventListener('keydown', (e)=>{ if(e.key==='d'||e.key==='D'){ undoPoint(); } if(e.key==='r'||e.key==='R'){ resetView(); } });

    function undoPoint(){ if(state.currentPts.length>0){ state.currentPts.pop(); draw(); return; } if(state.measurements.length>0){ state.measurements.pop(); renderMeasurementsList(); draw(); } }
    $("undo").onclick = undoPoint;
    $("clearAll").onclick = ()=>{ state.currentPts=[]; state.measurements=[]; state.baselinePts=[]; state.colorIdx=0; renderMeasurementsList(); draw(); };
    $("resetView").onclick = resetView;
    function resetView(){ if(state.img){ fitImage(); } draw(); }

    $("exportPNG").onclick = ()=>{
      const out = document.createElement('canvas');
      if(!state.img){ return; }
      out.width = state.imgNaturalW; out.height = state.imgNaturalH;
      const c2 = out.getContext('2d');
      c2.drawImage(state.img, 0, 0);
      drawOverlay(c2, 1, 0, 0, true);
      const link = document.createElement('a'); link.download = 'annotated_radiograph.png'; link.href = out.toDataURL('image/png'); link.click();
    };

    // ---------- Measurement math ----------
    function angleBetween(p1, p2, p3, p4){
      const vx = p2.x - p1.x, vy = p2.y - p1.y; const wx = p4.x - p3.x, wy = p4.y - p3.y;
      const vlen = Math.hypot(vx,vy), wlen = Math.hypot(wx,wy); if(vlen===0||wlen===0) return NaN;
      let cos = (vx*wx + vy*wy) / (vlen*wlen); cos = Math.min(1, Math.max(-1, cos));
      let ang = Math.acos(cos) * 180/Math.PI; if(ang > 180) ang = 360 - ang; if(ang > 90) ang = 180 - ang; return ang;
    }
    function angleToHorizontal(p1, p2){ const dx = p2.x - p1.x, dy = p2.y - p1.y; return Math.abs(Math.atan2(dy, dx) * 180/Math.PI); }
    function lineMidpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
    function lineIntersection(a,b,c,d){ const A1 = b.y - a.y; const B1 = a.x - b.x; const C1 = A1*a.x + B1*a.y; const A2 = d.y - c.y; const B2 = c.x - d.x; const C2 = A2*c.x + B2*c.y; const det = A1*B2 - A2*B1; if(Math.abs(det) < 1e-6){ const m1 = lineMidpoint(a,b), m2 = lineMidpoint(c,d); return { x:(m1.x+m2.x)/2, y:(m1.y+m2.y)/2 }; } const x = (B2*C1 - B1*C2)/det; const y = (A1*C2 - A2*C1)/det; return {x,y}; }

    function computeMeasurement(m){
      if(m.type==='HVA' || m.type==='IMA' || m.type==='LINE_LINE'){
        const [l1,l2] = m.lines; m.angle = angleBetween(l1[0], l1[1], l2[0], l2[1]); m.label = `${m.type}: ${m.angle.toFixed(1)}°`; m.anchor = lineIntersection(l1[0], l1[1], l2[0], l2[1]);
      } else if(m.type==='CALC_INC'){
        const calc = m.lines[0];
        if(state.baselineMode==='HORIZ' && !m.baseline){ const a = angleToHorizontal(calc[0], calc[1]); m.angle = a <= 90 ? a : 180 - a; m.label = `Calc Inclination: ${m.angle.toFixed(1)}° (to horiz)`; m.anchor = lineMidpoint(calc[0], calc[1]); }
        else { const base = m.baseline; m.angle = angleBetween(calc[0], calc[1], base[0], base[1]); m.label = `Calc Inclination: ${m.angle.toFixed(1)}° (to baseline)`; m.anchor = lineIntersection(calc[0], calc[1], base[0], base[1]); }
      }
    }

    function renderMeasurementsList(){
      const box = $("measurements"); if(state.measurements.length===0){ box.textContent = 'None yet.'; return; }
      box.innerHTML = state.measurements.map((m)=>{ return `<div style=\"margin:6px 0;\"><span style=\"display:inline-block;width:10px;height:10px;border-radius:50%;background:${m.color};margin-right:6px;\"></span><strong>${m.label}</strong></div>`; }).join('');
    }

    // ---------- Drawing ----------
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height); drawGrid();
      if(state.img){ ctx.save(); ctx.imageSmoothingEnabled = true; ctx.setTransform(state.scale, 0, 0, state.scale, state.offsetX, state.offsetY); ctx.drawImage(state.img, 0, 0); ctx.restore(); drawOverlay(ctx, state.scale, state.offsetX, state.offsetY, false); }
      drawHUD();
    }

    function drawGrid(){
      const step = 32 * dpr; ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle = '#0a0f25'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; for(let x=0; x<canvas.width; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); } for(let y=0; y<canvas.height; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); } ctx.restore();
    }

    function drawOverlay(c, scale, ox, oy, inImageSpace){
      function S(p){ if(inImageSpace) return p; return { x: (p.x * scale + ox), y: (p.y * scale + oy) }; }
      function drawPoint(p, color){ const s = S(p); c.save(); c.fillStyle = 'rgba(0,0,0,0.85)'; c.beginPath(); c.arc(s.x, s.y, 6*dpr, 0, Math.PI*2); c.fill(); c.fillStyle = color; c.beginPath(); c.arc(s.x, s.y, 4*dpr, 0, Math.PI*2); c.fill(); c.restore(); }
      function drawLine(a,b,color){ const s1 = S(a), s2 = S(b); c.save(); c.strokeStyle = color; c.lineWidth = 2*dpr; c.beginPath(); c.moveTo(s1.x, s1.y); c.lineTo(s2.x, s2.y); c.stroke(); c.restore(); }
      function drawLabel(text, p, color){ const s = S(p); c.save(); c.font = `${12*dpr}px ui-sans-serif, system-ui`; const pad = 4*dpr; const metrics = c.measureText(text); const w = metrics.width + pad*2, h = 18*dpr; c.fillStyle = 'rgba(0,0,0,0.65)'; c.fillRect(s.x - w/2, s.y - h/2, w, h); c.strokeStyle = 'rgba(255,255,255,0.3)'; c.strokeRect(s.x - w/2, s.y - h/2, w, h); c.fillStyle = color; c.fillText(text, s.x - w/2 + pad, s.y + 4*dpr - h/2); c.restore(); }

      for(const m of state.measurements){ const color = m.color; if(m.type==='CALC_INC' && m.baseline){ drawLine(m.baseline[0], m.baseline[1], 'rgba(255,255,255,0.35)'); } for(const ln of m.lines){ drawLine(ln[0], ln[1], color); drawPoint(ln[0], color); drawPoint(ln[1], color); } if(m.anchor && m.label){ drawLabel(m.label, m.anchor, color); } }
      const curColor = COLORS[(state.colorIdx) % COLORS.length];
      for(let i=0;i<state.currentPts.length;i++){ const p = state.currentPts[i]; if(i>0) drawLine(state.currentPts[i-1], p, curColor); drawPoint(p, curColor); }
      if(state.currentMode==='CALC_INC' && state.baselineMode==='CUSTOM'){ const b = state.baselinePts; if(b.length>0){ drawPoint(b[0], '#ffffff'); } if(b.length>1){ drawPoint(b[1], '#ffffff'); drawLine(b[0], b[1], 'rgba(255,255,255,0.6)'); } }
    }

    function drawHUD(){
      const ms = MODE_STEPS[state.currentMode]; const idx = state.currentPts.length; const text = ms ? ms.steps[Math.min(idx, ms.steps.length-1)] : '';
      $("hint").textContent = state.img ? `Tap to add point • ${text} ${state.currentMode==='CALC_INC' && state.baselineMode==='CUSTOM' ? '• Use ⓑ to add baseline pts (not implemented button) or hold ⌥ on desktop' : ''}` : 'Load an image or use the camera to begin.';
    }

    // Initialize canvas size
    resizeCanvas();

    // ---- PWA bootstrapping: runtime manifest + service worker ----
    (function setupPWA(){
      // Create a runtime manifest so the file stays single‑file
      const manifest = {
        name: "Radiograph Angle Tool",
        short_name: "Rad Angle",
        start_url: "./",
        scope: "./",
        display: "standalone",
        orientation: "portrait",
        background_color: "#0b1020",
        theme_color: "#0b1020",
        icons: [
          { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAByZJREFUeNrs3TGR2zYQBVCP//+bA0bQK2x+1m1lYzKqvHnB1S0Q1m9m0vW9F5E1Gv3m8b3wq8s2r79wWgAAEBy3dVtVbVYqFovl8vlEolkslk0tPTU1NTk8lkMmZmZrHdbldXV5fP58cHBwWFhYbIsC2Ww2m82srKxSqVS6urrq9Xr9bDZb3G63bW1tVquVx+Px8fHx4eHh2Ww2q9Vq5XK5ZDKZfD4fAAAgPz7m8vGwsLCwsLCwq5fLZbfb7fb6+rqenp6cHBw0NHRsCwLAAAAgKt9U3yqXq/X4/H4vHx8vLy8bIsC0aj0Wg0eXl5bW1t9fX1nJyc5OTkYDAYrFar3W53fX19e3t7EokEAAAAP8n7xgAAABg6C5nAgAAAGDoLmcCAAAAYOgudwIABN8mE0xF8g8B7V3b2b8I2l7AAAAAElFTkSuQmCC", sizes: "512x512", type: "image/png"}
        ]
      };
      const blob = new Blob([JSON.stringify(manifest)], {type:'application/manifest+json'});
      const url = URL.createObjectURL(blob);
      const link = document.getElementById('pwa-manifest');
      if(link) link.href = url;

      // Show install banner on platforms that support it
      let deferredPrompt = null;
      window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredPrompt = e; const el = document.getElementById('installBanner'); if(el) el.style.display = 'block'; });
      document.getElementById('dismissInstall')?.addEventListener('click', ()=>{ const el = document.getElementById('installBanner'); if(el) el.style.display = 'none'; });
      document.getElementById('installBtn')?.addEventListener('click', async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); const { outcome } = await deferredPrompt.userChoice; deferredPrompt = null; document.getElementById('installBanner').style.display='none'; });

      // Service worker: cache this file for offline use
      if('serviceWorker' in navigator){
        const sw = `const CACHE='rt-mobile-v2';
self.addEventListener('install',e=>{e.waitUntil(caches.open(CACHE).then(c=>c.addAll([location.pathname])))});
self.addEventListener('activate',e=>{e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==CACHE).map(k=>caches.delete(k)))))});
self.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)))})`;
        const swBlob = new Blob([sw], {type:'text/javascript'});
        const swURL = URL.createObjectURL(swBlob);
        navigator.serviceWorker.register(swURL).catch(()=>{});
      }
    })();
  </script>
</body>
</html>
